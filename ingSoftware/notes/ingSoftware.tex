\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}

\usepackage{graphicx}

\usepackage{geometry}

\usepackage{multicol}
\usepackage{listings}


\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\geometry{margin=0.6in}


\setlength{\parindent}{0em}
\setlength{\parskip}{1em}
\title{Ingegneria del software}

\begin{document}
\section{Introduzione}
Lo sviluppo di un software segue le seguenti dinamiche: il cliente ha  un problema e dei requisiti che 
vengono implementati nel software

Un software vive, e di conseguenza si evolve, durante questa evoluzione si sono notate delle 
caratteristiche come il cambiamento continuo, la complessità incrementale, il declino costante e la 
crescità continua. 

Il processo software, o l'insieme di attività per lo sviluppo ed evoluzione di un programma, comprende 
specifica sviluppo convalida ed evoluzione. 

Il processo segue un modello specifico (waterfall, iterative,...). A nostra disposizione abbiamo diversi 
metodi, strumenti e standard

\newpage
\section{Processo di sviluppo}
Il processo di sviluppo stabilisce quando e come qualcuno fa cosa, per raggiungere un determinato obiettivo

\subsection{Scelta e adattamento}
Per identificare il modello più adatto dipende da vari motivi, tra cui anche il problema da affrontare o il team di 
sviluppo. In ongi caso le differenze principali fra i vari modelli sono: 
\begin{itemize}
    \item flusso delle attività
    \item dettaglio e rigore del processo
    \item coinvolgimento degli stake holders
    \item autonomia del team
    \item ...
\end{itemize}

\subsection{Modelli}
\subsubsection{Modello a cascata}
il processo di lavoro procede in maniera lineare, senza tornare indietro 
\begin{center}
    Comunicazione $\Rightarrow$ pianificazione $\Rightarrow$ modellazione $\Rightarrow$ costruzione 
    $\Rightarrow$ deployment
\end{center}
Questo modello porta il vantaggio della parallelizazione, grazie alla sua struttura simile a una catenda di montaggio.
Sfortunatamente, se durante la fase di costruzione si trova un problema nel design, necessità di ritornare alla 
fase di modellazione, rompento il modello

\subsubsection{Modello di processo incrementale}
Questo modello utilizza sempre il processo a cascata, ma a ripetizione, con incrementi costanti durante tutta
l'evoluzione del software. Importante da ricordare che il sistema incrementale opera sul software solo per aggiunte,
non torna mai ad aggiornare le funzioni precedentemente implementate.

\subsubsection{Modello a prototipi}
Nel caso il cliente non conosca precisamente le specifiche richieste nel progetto, allora si può procedere per 
prototipi. Seguendo questo modello, si entra in un ciclo di progettazione e feedback del cliente fino a quando non 
si raggiunge un prototipo che soddisfa i bisogni del cliente.

NB: viene definito nel Def ISO 13407

Il prototipo non deve essere per forza un prodotto finito o funzionante, ma anche un modello finto (o mock-up).
Generalmente si costruscono un wireframe, ossia una bozza grafica per mostrare la user expirience, e poi 
successivamente ci si sposta sul mock-up

Uno svantaggio di questo modello è che il cliente potrebbe pensare che il prototipo sia un prodotto finito, 
e la successiva mediazione con gli sviluppatori può portare a uno sviluppo rapido e di qualità scadente.

\subsubsection{Modello a spirale}
Il modello a spirale sfrutta una ciclicità basata sul feedback del cliente, per poi riprendere le fasi di
sviluppo partendo dai risultati del confronto

\subsubsection{Sviluppo a componenti}
In questo caso si sfruttano componenti software con funzionalità mirate e interfacce ben definite.
I componenti più semplici risultano riusabili, ma non possono risolvere problemi complessi, per questo si può usare
una composizione di componenti

\subsubsection{Archittettura orientata ai servizi}
Una variante dello sviluppo a componenti va a sostituire le componenti con i servizi

\subsubsection{Model-driven Development}

\subsection{Metodologie Agile}
È un metodo di sviluppo che coinvolge il più possibile il committente, per ottenere una elevata reattività alle
sue richieste.

\subsubsection{Modello scrum}
È un modello agile con l'obbiettivo di ridurre l'overhead organizzativo. È caratterizato da piccoli team di lavoro,
costante testing e produzione di documentazione e frequenti incrementi software. 

Il progetto viene diviso in piccoli blocchi di lavoro (sprint), che poi confronta i risultati con il cliente ed 
elabora le attività dell'immediato futuro (backlog). Infine, con cadenza giornaliera, i vari gruppi si organizzano in 
una riunione (daily scrum) per fare il punto della situazione

\subsubsection{Extreme programming}
È una prassi che si concentra su diversi punti riassumibili in feedback a scala fine, processo con/nuo, comprensione
condivisa, benessere dei programmatori. Altri 3 punti molto importanti sono un'integrazione delle modifiche frequente,
così da limitare i conflitti dati dal nuovo codice, un refactoring piuttosto pesante e piccole ma frequenti realeases

La fase di plannign è caratterizzata dall'utilizzo delle user stories che descrivono funzionalità e caratteristiche,
le quali vengono poi classificate e organizzate nelle tempistiche del progetto. Il cliente e il team di sviluppatori
collaborano nella gestione e scelta delle user stories per la release successiva.

Nella fase di programmazione, gli sviluppatori lavorano a coppie (con ruoli distinti) e poi il loro lavoro viene
integrato da un team apposito a quello del resto del team. Questo genera un'integrazione continua che riduce i 
problemi di compatibilità e interfacciamento.

Infine la fase di testing si avvale di strumenti per l'automazione degli unit test, mentre la valutazione del cliente
si limita sulle funzioni e caratteristiche globali di sistema

\subsubsection{DevOps}
Il DevOps è un modello che si applica a grandi infrastrutture che necessitano di una gestione rapida e efficente tra 
il Development team e l'operation team. Il modello si basa sulla virtualizzazione nel cloud, su sistemi automatizati
e metodi agile per l'interazione tra sviluppatori e sistemisti

\subsection{Modularizzazione}
L'Archittettura più diffusa è quella dei microservizi, molto ad


\newpage
\section{Linguaggi di modellazione}
Un ingegnere del software per sviluppare un progetto necessità di un linguaggio comune per farsi da comprendere
da altri ingegnieri.

La scelta del linguaggio può variare in base a vari parametri come facilità d'uso, comprensibilità per non tecnici,
formalità e precisione

\subsection{Linguaggio entity-relationship}
Usato principalmente nel mondo dei database

\subsection{Business Process Modelling notation}
Lo standard OMG per la rappresentazione dei processi business è BPMN  

\subsection{Sicurezza}
Diversi approcci SRE (Security Requirements Engineering) utilizzano dei linguaggi di modellazione, questo permette
la creazione di documentazione più precisa e analisi automatizate. Questi linguaggi variano in base al obbiettivo che
vogliono rappresentare 

Alcuni di questo metodi usano delle basi di UML, o si concentrano sull'obbiettivo degli attaccanti

\subsection{Linguaggio OCL}
L'Object Constraint Language è un linguaggio funzionale usato per esprimere espressioni e vincoli sui modelli object
oriented. È basato sull'utilizzo di query che vengono usate per specificare valori iniziali e derivati di un 
attributo, o indicare la condizione di un diagramma dinamico, oppure le query applicano dei vincoli di tipo
invariante, precondizione, postcondizione o guardia.

In questo tipo di linguaggio il contesto di un'espressione è decisivo

\newpage
\section{Requisiti}
I bisogni di un cliente possono essere espressi come scopi. Nello sviluppo di un progetto dovremmo creare delle 
funzioni che permettano di conseguire questi scopi.

Secondo Micheal Jackson, I requisiti sono la dati dalla somma di assunzioni sull'ambiente e dalle specifiche del 
sistema

I requisiti passano una definizione, ovvero quando vengono definiti per il cliente con un linguaggio comune, e
poi la specifica, ossia un documento più strutturato e specifico scritto per gli sviluppatori.\\ Il processo 
di acquisizione dei requisiti si chiama elicitazione

\subsection{Difficoltà nell'analisi dei requisiti}
Effettuare un'elicitazione può presentare delle difficoltà: per esempio uno stakeholder può non avere un'idea chiara
o utilizzare un linguaggio tipico del dominio che l'analista non conosce, o magari diversi stakeholders possono avere 
richieste differenti. Questo poi provoca errori che più a lungo rimangono nascosti, più aumentano i costi di 
riparazione

\subsection{Categorie di requisiti}
I requisiti devono descrivere cosa il sistema deve offrire, e si dividono in funzionali e non. I primi descrivono cosa
un sistema dovrebbe fare, mentre i secondi esprimono il come.
\subsubsection*{Requisiti funzionali}
Descrivono le funzionalità del sistema software, in termini di servizi che deve offrire l'applicativo, di come reagisce 
a determinati input e altri comporamenti specifici. Questo tipo di requisito deve essere particolarmente completo e
coerente

\subsubsection*{Requisiti non funzionali}
Descrivono le proprietà del sistema in relazione a determinati servizi offerti. I requisiti non funzionali sono difficili 
da verificare, dato che sono formati sia da obiettivi generali che da obiettivi vaghi, e soggetti all'interpretazione 
dello sviluppatore.\\Generalmente contiene misurazioni quantitative come velocità, dimensione, affidabilità,\dots

\subsection{Forma del requisito}
Può essere scritta in 3 modi: classico, user experience e caso d'uso
\subsubsection*{User story}
seguono la forma del "as a ... I want ... so that ..." e contengono intrisicamente il criterio d'accettazione.
\subsubsection*{Use case}
Il caso d'uso è uno studio degli scenari operativi degli utenti di un sistema, ossia i modi in cui il sistema può essere 
utilizzato. Nello specifico è una sequenza di azioni che producono un risultato osservabile da un attore. Queste 
sequenze vengono chiamate scenari e possono riguardare un caso base (di successo) o presentare degli scenari alternativi
(in caso di insuccesso o varianti). 

Il processo di creazione di uno schema richiede l'individuazione degli attori e degli scenari, e successivamente La
creazione di relazioni tra i due

\subsection{Sequence diagram}
This diagram shows how objects collaborate between them. It's composed typicaly by time (or the progression of it), 
messages (the communications between two objects) and the focus of control (the period while an object is performing an
action)

\subsection{State machine diagram}
It describes the sequence of states and action an element can proceed. It's composed of a start and stop states and
transitions divided in events, guards and actions. The action happen on entry, exit and while (do) in a state.

They can be semplified in a hierachical decomposition, but this causes information losses and cluttering

\subsection{Activity diagrams}
It follows the same logic of the state machine diagram, but adds forks, joins and decisions. They could be
separated in swinlanes to show who is the actor of that action.

\subsection{Diagramma di contesto}
Modella l'interazione tra il software e entità esterne, tipicamenti sistemi superiori, subordinati, paritari e
gli attori

La costruzione segue le seguenti fasi:
\begin{enumerate}
    \item identificazione dei flussi d'informazione
    \item identificazione delle entità esterne
    \item rappresentazione del sistema da sviluppare
    \item rappresentazione delle entità esterne
    \item collegamento dei flussi d'informazione
\end{enumerate}
Successivamente si può anche individuare la tipologia di sistemi e attori

\section{Businness Process Modeling Notation}
A businness process is a set of activities that jointly realize a businness goal. This requires that organizations 
specify their flows of work.

BPMN is the OMG standard for representing businness processes. At his core we represent the components of a 
software system, the data they exchange and manipulate, and the various systems.\\ In practice we represent:
\begin{itemize}
    \item Events (circles)
    \subitem Start
    \subitem intermediate (double circle)
    \subitem end (thick circle)
    \item Tasks (squares)
    \item Flows (arrows)
    \item Gateways (diamonds)
\end{itemize}


\subsection{Events}
Non-interrupt events are rappresented with a dotted line.
\begin{itemize}
    \item Message 
    \item Timer 
    \item Conditional 
    \item Link 
    \item Signal 
    \item Error 
    \item Escalation 
    \item Termination 
    \item Compensation 
    \item Cancel 
    \item Multiple 
    \item Multiple parallel 
\end{itemize}

\subsection{Tasks}
Tasks, or activities, is a work performed within a businnes process. Are divided in tasks, subprocesses (+)
and call activities (thick line)

Tasks:
\begin{itemize}
    \item Abstract Task 
    \item Service Task 
    \item Send Task 
    \item Receive Task 
    \item User Task 
    \item Manual Task 
    \item Businness Rule Task
    \item Script Task 
    \item Loop Task 
    \item Sequential/Parallel Task
\end{itemize}

Sub-processes:
\begin{itemize}
    \item Adhoc subprocess (tilde): The order of their constituent tasks is unspecified
    \item Transaction (double line): A set of activities that must be performed atomically, or indivisible
    \item Event Sub process (dotted line): Sub processes generated by events
\end{itemize}

Call activies:
These are references to external processes or to recall processes already defined

\begin{itemize}
    \item Abstract Call Activity
    \item User Call Activity
    \item Manual Call Activity
    \item Businnes Rule Call Activity
    \item Script Call Activity
\end{itemize}

\subsection{Gateways}

\begin{itemize}
    \item Exclusive Gateways
    \item Inclusive Gateways
    \item Parallel Gateways
    \item Complex Gateways
    \item Event-based Gateways
    \subitem Event-based Gateways to start a process
    \subitem Parallel Event-based Gateways to start a process
\end{itemize}


\end{document}
