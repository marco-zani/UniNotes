\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}

\usepackage{graphicx}

\usepackage{geometry}

\usepackage{multicol}
\usepackage{listings}


\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\geometry{margin=0.6in}


\setlength{\parindent}{0em}
\setlength{\parskip}{1em}
\title{Ingegneria del software}

\begin{document}
\section{Introduzione}
Lo sviluppo di un software segue le seguenti dinamiche: il cliente ha  un problema e dei requisiti che 
vengono implementati nel software

Un software vive, e di conseguenza si evolve, durante questa evoluzione si sono notate delle 
caratteristiche come il cambiamento continuo, la complessità incrementale, il declino costante e la 
crescità continua. 

Il processo software, o l'insieme di attività per lo sviluppo ed evoluzione di un programma, comprende 
specifica sviluppo convalida ed evoluzione. 

Il processo segue un modello specifico (waterfall, iterative,...). A nostra disposizione abbiamo diversi 
metodi, strumenti e standard

\newpage
\section{Processo di sviluppo}
Il processo di sviluppo stabilisce quando e come qualcuno fa cosa, per raggiungere un determinato obiettivo

\subsection{Scelta e adattamento}
Per identificare il modello più adatto dipende da vari motivi, tra cui anche il problema da affrontare o il team di 
sviluppo. In ongi caso le differenze principali fra i vari modelli sono: 
\begin{itemize}
    \item flusso delle attività
    \item dettaglio e rigore del processo
    \item coinvolgimento degli stake holders
    \item autonomia del team
    \item ...
\end{itemize}

\subsection{Modelli}
\subsubsection{Modello a cascata}
il processo di lavoro procede in maniera lineare, senza tornare indietro 
\begin{center}
    Comunicazione $\Rightarrow$ pianificazione $\Rightarrow$ modellazione $\Rightarrow$ costruzione 
    $\Rightarrow$ deployment
\end{center}
Questo modello porta il vantaggio della parallelizazione, grazie alla sua struttura simile a una catenda di montaggio.
Sfortunatamente, se durante la fase di costruzione si trova un problema nel design, necessità di ritornare alla 
fase di modellazione, rompento il modello

\subsubsection{Modello di processo incrementale}
Questo modello utilizza sempre il processo a cascata, ma a ripetizione, con incrementi costanti durante tutta
l'evoluzione del software. Importante da ricordare che il sistema incrementale opera sul software solo per aggiunte,
non torna mai ad aggiornare le funzioni precedentemente implementate.

\subsubsection{Modello a prototipi}
Nel caso il cliente non conosca precisamente le specifiche richieste nel progetto, allora si può procedere per 
prototipi. Seguendo questo modello, si entra in un ciclo di progettazione e feedback del cliente fino a quando non 
si raggiunge un prototipo che soddisfa i bisogni del cliente.

NB: viene definito nel Def ISO 13407

Il prototipo non deve essere per forza un prodotto finito o funzionante, ma anche un modello finto (o mock-up).
Generalmente si costruscono un wireframe, ossia una bozza grafica per mostrare la user expirience, e poi 
successivamente ci si sposta sul mock-up

Uno svantaggio di questo modello è che il cliente potrebbe pensare che il prototipo sia un prodotto finito, 
e la successiva mediazione con gli sviluppatori può portare a uno sviluppo rapido e di qualità scadente.

\subsubsection{Modello a spirale}
Il modello a spirale sfrutta una ciclicità basata sul feedback del cliente, per poi riprendere le fasi di
sviluppo partendo dai risultati del confronto

\subsubsection{Sviluppo a componenti}
In questo caso si sfruttano componenti software con funzionalità mirate e interfacce ben definite.
I componenti più semplici risultano riusabili, ma non possono risolvere problemi complessi, per questo si può usare
una composizione di componenti

\subsubsection{Archittettura orientata ai servizi}
Una variante dello sviluppo a componenti va a sostituire le componenti con i servizi

\subsubsection{Model-driven Development}

\subsection{Metodologie Agile}
È un metodo di sviluppo che coinvolge il più possibile il committente, per ottenere una elevata reattività alle
sue richieste.

\subsubsection{Modello scrum}
È un modello agile con l'obbiettivo di ridurre l'overhead organizzativo. È caratterizato da piccoli team di lavoro,
costante testing e produzione di documentazione e frequenti incrementi software. 

Il progetto viene diviso in piccoli blocchi di lavoro (sprint), che poi confronta i risultati con il cliente ed 
elabora le attività dell'immediato futuro (backlog). Infine, con cadenza giornaliera, i vari gruppi si organizzano in 
una riunione (daily scrum) per fare il punto della situazione

\subsubsection{Extreme programming}
È una prassi che si concentra su diversi punti riassumibili in feedback a scala fine, processo con/nuo, comprensione
condivisa, benessere dei programmatori. Altri 3 punti molto importanti sono un'integrazione delle modifiche frequente,
così da limitare i conflitti dati dal nuovo codice, un refactoring piuttosto pesante e piccole ma frequenti realeases

La fase di plannign è caratterizzata dall'utilizzo delle user stories che descrivono funzionalità e caratteristiche,
le quali vengono poi classificate e organizzate nelle tempistiche del progetto. Il cliente e il team di sviluppatori
collaborano nella gestione e scelta delle user stories per la release successiva.

Nella fase di programmazione, gli sviluppatori lavorano a coppie (con ruoli distinti) e poi il loro lavoro viene
integrato da un team apposito a quello del resto del team. Questo genera un'integrazione continua che riduce i 
problemi di compatibilità e interfacciamento.

Infine la fase di testing si avvale di strumenti per l'automazione degli unit test, mentre la valutazione del cliente
si limita sulle funzioni e caratteristiche globali di sistema

\subsubsection{DevOps}
Il DevOps è un modello che si applica a grandi infrastrutture che necessitano di una gestione rapida e efficente tra 
il Development team e l'operation team. Il modello si basa sulla virtualizzazione nel cloud, su sistemi automatizati
e metodi agile per l'interazione tra sviluppatori e sistemisti

\subsection{Modularizzazione}
L'Archittettura più diffusa è quella dei microservizi, molto ad


\newpage
\section{Linguaggi di modellazione}
Un ingegnere del software per sviluppare un progetto necessità di un linguaggio comune per farsi da comprendere
da altri ingegnieri.

La scelta del linguaggio può variare in base a vari parametri come facilità d'uso, comprensibilità per non tecnici,
formalità e precisione

\subsection{Linguaggio entity-relationship}
Usato principalmente nel mondo dei database

\subsection{Business Process Modelling notation}
Lo standard OMG per la rappresentazione dei processi business è BPMN  

\subsection{Sicurezza}
Diversi approcci SRE (Security Requirements Engineering) utilizzano dei linguaggi di modellazione, questo permette
la creazione di documentazione più precisa e analisi automatizate. Questi linguaggi variano in base al obbiettivo che
vogliono rappresentare 

Alcuni di questo metodi usano delle basi di UML, o si concentrano sull'obbiettivo degli attaccanti

\subsection{Linguaggio OCL}
L'Object Constraint Language è un linguaggio funzionale usato per esprimere espressioni e vincoli sui modelli object
oriented. È basato sull'utilizzo di query che vengono usate per specificare valori iniziali e derivati di un 
attributo, o indicare la condizione di un diagramma dinamico, oppure le query applicano dei vincoli di tipo
invariante, precondizione, postcondizione o guardia.

In questo tipo di linguaggio il contesto di un'espressione è decisivo

\newpage
\section{Requisiti}
I bisogni di un cliente possono essere espressi come scopi. Nello sviluppo di un progetto dovremmo creare delle 
funzioni che permettano di conseguire questi scopi.

Secondo Micheal Jackson, I requisiti sono la dati dalla somma di assunzioni sull'ambiente e dalle specifiche del 
sistema

I requisiti passano una definizione, ovvero quando vengono definiti per il cliente con un linguaggio comune, e
poi la specifica, ossia un documento più strutturato e specifico scritto per gli sviluppatori.\\ Il processo 
di acquisizione dei requisiti si chiama elicitazione


\end{document}
