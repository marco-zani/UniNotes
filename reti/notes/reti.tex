\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}

\usepackage{graphicx}

\usepackage{geometry}

\usepackage{multicol}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\geometry{margin=0.6in}


\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\title{Reti}

\begin{document}

\tableofcontents
\newpage

\section{Introduzione}

La rete può essere vista come un insieme di terminali, collegamenti e nodi, che utilizzano varie tipologie di comunicazione.

Alcune di queste metodologie sono i sistemi terminali (Dove si collegano tutti a un mainframe), l'architettura client/server 
e la peer-to-peer (che rimuove o limita l'utilizzo di server)

\subsection{Collegamenti}
Le reti di accesso si generalizzano in 3 categorie: accesso residenziale, accesso aziendale e accesso mobile.

L'accesso residenziale punto-punto utilizza tecnologie come la FTTH per fornire linee internet limitate a una residenziale.
Le componenti tipiche sono il modem, il router, il firewall, il NAT e l'access point. Generamente ritroviamo tutte queste 
componenti unite nell'unico "router" casalingo

In un accesso aziendale le tecnologie aumentano, vediamo l'introduzione della LAN e collegamenti via Ethernet

Infine vediamo le tecnologie wireless, che, attraverso un access point, forniscono linea attraverso l'etere

\subsubsection*{Mezzi trasmissivi}
Il mezzo fisico che connette i dispositivi rientra nella categoria dei mezzi guidati o nelle onde libere. Il mezzo guidato
più comune è il filo di rame a doppino intrecciato (TP). Le sigle dei doppini identificano i vari tipi di schermatura, 
la parte sinistra è la schermatura dell'intero cavo (Unshielded, Foiled, Shielded o maglia metallica) e la parte destra 
indica il singolo doppino (Unshielded and Shielded). Questi casi possono anche essere più o meno incrociati (cross o patch)
da un connettore all'altro. Questo permette di connettere direttamente due terminali. 


Per I mezzi a onde libere abbiamo le microonde terrestri, le WiFi LAN, le Wide area e le satelittari. Questo tipo di 
propagazione è più vulnerabile agli effetti dell'ambiente di propagazione

\subsubsection*{Nucleo della rete}
Il trasferimento dei dati nella rete avviene tramite commutazione di circuito o commutazione di pacchetto. Il primo metodo 
era quello classico della rete telefonica, il che comportava l'assenza di condivisione delle risorse. La rete viene suddivisa 
in porzioni con ripartizione della banda tramite divisione in frequenza o tempo. Nel caso le risorse non vengono utilizzate
allora rimangono inattive

\subsection{Struttura di internet}
Internet è strutturato gerarchicamente. Nel punto più alto troviamo gli ISP di liv 1 che forniscono copertura nazionale se 
non addirittura internazionale. Le comunicazioni fra di loro vengono considerate fra pari (peer).
Successivamente l'ISP di livello 1 vende copertura agli ISP di liv 2, che sono in grado di comunicare con altri ISP di 
liv 2 e un numero limitato di ISP liv 1. Infine abbiamo infine le reti di ISP di liv 3 e reti locali. Queste reti vengono 
definite reti di ultimo salto (last hop)

In queste reti sono disponibili gli IXP (Internet eXchange Point), ovvero edifici dove gli ISP di livello 2 comunicano fra 
di loro direttamente

\subsection*{Ritardi e Perdite}
Se troppi pacchetti arrivano in un router che non riesce a processarli in tempi brevi, allora i pacchetti vengono accodati.
Questi problemi avvengono in 4 casistiche

\subsubsection*{elaborazione del nodo}
Questi problemi avvengono a causa del controllo sugli errori del bit o per la scelta del canale d'uscita

\subsubsection*{Ritardo per accodamento}
I pacchetti si fermano nel router in attesa di trasmissione o per congestione del router

\subsubsection*{Ritardo di trasmissione}
Ritardo all'interno di un dispositivo di rete

\subsubsection*{Ritardo di propagazione}
Ritardo dato dalla trasmissione del mezzo trasmissivo tra due dispositivi di rete


Quindi il ritardo del nodo è dato dalla somma di ritardo di elaborazione (processing delay), ritardo di accodamento 
(queuing delay), ritardo di trasmissione (transmission delay) e ritardo di propagazione (propagation delay)
\begin{center}
    $d_{node}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$
\end{center}

Un'altra formula importante è quella del ritaro d'accomodamento, che è dato dalla lunghezza del pacchetto per il tasso 
medio di arrivo dei pacchetti, il tutto fratto il bitrate
\begin{center}
    $\frac{A\times L}{R}$
\end{center}

\subsection{Livelli di protocollo}
Ogni protocollo viene organizzato su vari livelli in base al suo ruolo, questa strategia si chiama stratificazione e 
permette semplificare l'identificazione di un protocollo e le sue funzioni. Inoltre le modifiche a un determinato 
livello risulta trasparente rispetto agli altri layers.

I layer sono in grado di fornire servizi al layer superiore, mentre utilizzano quelle del livello inferiore. Questi 
servizi vengono forniti attraverso i SAP (Service Access Point). Questi layer sono 5 nella struttura Tcp/ISP

\subsubsection*{Applicazione}
Fornisce alle applicazioni i mezzi per scambiarsi i dati. A questo livello le data unit si chiamano messaggi.
\subsubsection*{Transporto}
Gestisce i problemi di qualità del livello di rete, applica la segmentazione e ricomposizione dei dati, multiplexing. 
Applica anche controlli di flusso, errore e riordino dei pacchetti. Le data unit vengono chiamate segmenti
\subsubsection*{Rete}
Responsabile dell'instradamento dei dati tra un host e l'altro. Offre servizi connection-less o connection-oriented 
(l'indipendenza durante l'instadazione tra un pacchetto e l'altro). Le data unit vengono chiamate pacchetti o datagrammi
\subsubsection*{Collegamento}
Si occupa di multiplexing, effettua controlli e correzzioni di errori e implementa il MAC (Medium Access Controll).
Le data unit vengono chiamate frame
\subsubsection*{Fisico}
trasferimento dei singoli bit sul mezzo di comunicazione (elettrico, elettromagnetico, luminoso,...). Fornisce i servizi per
creare, mantenere e distruggere le connessioni fisiche

Nel modello ISO/OSI si aggiungono anche i livelli presentazione e sessione che si occupano di cifrature e 
sincronizzazione

\subsubsection{Data units}
In un sistema con $N$ layers, i dati trasmessi compongono una $N$-SDU, o una Service Data Unit di layer $N$, dove viene poi
incapsulata dalle Data Unit di livello inferiore formando una PDU (Protocoll DU).\\Man mano che la PDU scende nei layer 
vengono aggiunti diversi header, che successivamente vengono disassemblate dal ricevitore. A causa delle dimensioni della
PDU possiamo segmentarla in PDU di dimensione ridotta oppure unire diverse PDU di piccole dimensioni in un singolo messaggio

\subsection{Sicurezza}
Internet non è stato pensato con il pallino della sicurezza. Attraverso internet, gli attaccanti sono in grado di inviare 
virus, worms, e trojans, senza contare programmi di spionaggio e botnets. C'è anche la possibilità di anilisi dei pacchetti
in transito sulla rete (packet sniffing), o l'invio di pacchetti con un indirizzo di origine falso (IP Spoofing) o il 
reinvio di pacchetti sensibili (Record-and-Playback)

\newpage
\section{Livello applicazione}
\subsection{Architetture delle applicazioni di rete}
\subsubsection*{Archittettura client server}
I server sono host sempre attivi e con indirizzo fisso, mentre il client può disconnettersi, avere link dinamici e 
non comunicare direttamente con altri client.\\Questa archittettura ha la difficolta della scalabilità.

\subsubsection*{Peer-to-peer}
Non viene usato un server sempre attivo, ma vengono usate coppie di host con la capacità di diventare inattivi o usare indirizzi
dinamici. Questa archittettura è facile da scalare ma difficile da gestire

\subsubsection*{Ibridi}
Le versioni ibride sono molto differenti fra loro, ma prendendo in esempio skype, utilizza chiamate peer-to-peer, ma un 
server centralizzato per la ricerca degli indirizzi

\subsubsection*{Cloud}
Un'insieme di tecnologie in grado di gestire dati con risorse distribuite in rete. Tutti i dati sono memorizzate in server
farm

\subsection{Processi comunicanti}
all'interno dello stesso host, due processi comunicano utilizzando schemi interprocesso. I processi client e server esprimono
processi che danno inizio alla comunicazione o attendono di essere contattato.

\subsubsection*{Socket}
Un processo invia e riceve da una socket (o porta). Viene pressupposto che esista un'infrastruttura esterna in grado di 
trasportare il messaggio fino alla socket destinataria.

Per la communicazione oltre all'indirizzo IP viene anche esplicitata la porta sulla quale comunica in maniera da identificare
il processo ricevente

\subsection{Protocolli a livello applicazione}
Esistono una marea di protocolli, ma principalmente si dividono in protocolli proprietari, come skype, o protocolli
di dominio pubblico, come http,smtp,...

\subsection{Interazione con il livello di trasporto}
Il livello di applicazione usa diversi servizi dal livello inferiore, come la gestione della perdita di dati, il quantitativo
di throughput, e servizi di sicurezza come la cifratura.

\subsection{Protocolli}
\subsubsection{HTTP}
Protocollo a modello client/server, dove il client esegue richieste di oggetti web e il server risponde con gli oggetti richiesti.
HTTP usa una connessione TCP sulla porta 80. HTTP è un protocollo stateless, ovvero senza che il server tenga informazioni sulle
richeiste del client.

Le connessioni HTTP sono sia persistenti che non, ossia possono inviare un singolo oggetto come molteplici. La comunicazione
generalmente segue questa falsa riga:
\begin{enumerate}
    \item il client inizializza una connessione TCP con il server
    \item Il server accetta la connessione
    \item Il client invia un richiesta con l'url della risorsa
    \item Il server risponde inoltrando l'oggetto richiesto e chiude la connessione
    \item il client riceve il file HTML e trova il riferimento agli oggetti richiesti
\end{enumerate}
Il tempo di propagazione e ritorno tra due host viene chiamato Round Trip Time (RTT).

Le connessioni non persistenti richiedono 2RTT per oggetto, l'hoverhead del SO per ogni connessione e connessioni TCP parallele.
Mentre nelle connessioni persiste il server lascia la porta aperta permettendo di spostare i messaggi all'interno della stessa 
connessione.

HTTP usa due messaggi: richiesta e risposta.\\La richiesta è formata da una riga di richiesta (GET, POST, PUT, DELETE) e delle 
righe di intestazione e il corpo dell'entità.\\La risposta è formata dalla riga di stato, righe di intestazione e dati.

Una pagina web è costituita da oggetti e un file base scritto in html. Ogni oggetto è referenziato da un URL (Uniform Resource 
Location)

HTTP utilizza i cookies per mantenere dati come autorizzazioni, stato delle sessioni, raccomandazioni. I cookie permettono
ai siti di imparare molte cose sugli utenti.\\Utilizzano quattro componenti: una riga nell'intestazione dei messaggi di 
richiesta e risposta, un file mantenuto sul sistema del client e un database sul sito

Un'altro servizio è quello della cache web, ossia un sistema che soddisfa la richiesta del client senza coinvolgere il server.
Il client viene configurato per effettuare richieste a un proxy, nel momento in cui il proxy possiede già la risorsa richiesta,
risponde direttamente al client, se no inoltra la richiesta al server d'origine.\\Tutto questo processo permette di ridurre 
la latenza e il traffico internet

HTTP 2.0 è un'evoluzione focalizzata sulle prestazioni con l'obiettivo di utilizzare un'unica connessione dai browsers a 
un server.\\Si basa su SPDY, un protocollo livello applicazione con l'obiettivo di trasmettere contenuti con la minima 
latenza tramite multiplexing, priorità delle richieste e compressione dell'header HTTP. Tutte le connessioni HTTP/2
sono persistenti

Il framing binario in HTTP 2.0 usa la stessa semantica ma una codifica diversa, con messaggi più piccoli e codificati in 
binario. Tutte le comunicazioni in una singola connessione TCP può portare molteplici stream di byte, ognuno con identificativo 
univoco. Ogni stream trasmette vari messaggi che sono composti a loro volta da frames, la più piccola unità di 
comunicazione. Questi frames possono essere interposti e riassemblati tramite il loro identificatore

Grazie al nuovo livello di framing binario,  HTTP/2 consente l'uso del multiplexing, dove client e server possono dividere
i messaggi in frame indipendenti, di intervallarli e ricomporli a destinazione. Con questo metodo l'ordine dei frames 
diventa critico per le prestazioni, infatti agli streams viene assegnato un peso da 1 a 256 con la quale l'host può
definire degli alberi di priorità per l'invio dei frames

Ultima funzionalità è quella del server push, ossia che il server è in grado di inviare ulteriori risorse collegate a quella
richiesta dal client con un'unica query. In questo modo le risorse necessarie per far funzionare un'applicazione web vengono
inviate con un solo messaggio di risposta, risparmiando risorse e tempo al server

\subsection{FTP}
È un protocollo di tipo client/server che permette il trasferimento di file. Il servizio usufruisce della porta 21

\subsection{Posta elettronica}
Nella posta elettronica abbiamo 3 componenti principali: l'agente utente, il server di posta e il protocollo.

L'agente utente, o mail reader, si occupa di composizione, editing e lettura dei messaggi memorizzati sul server. Il server
di posta contiene la coda dei messaggi, la casella di posta e gestisce il protocollo di comunicazione tra server e server
per inviare e ricevere mails

\subsubsection{SMTP}
questo protocollo usa connessioni tcp persistenti per trasferire in modo affidabile le mail in maniera diretta. Il 
trasferimento è gestito in 3 fasi: handshake, trasferimento dei messaggi e chiusura.
I comandi sono composti in un testo ascii 7 bit, e le risposte tramite codici di stato ed espressioni.\\ La porta
usata è 465

Per l'utilizzo di messaggi multimediali, viene aggiunta l'estensione MIME

\subsubsection*{Protocolli d'accesso alla posta}
Mentre SMTP gestisce il trasferimento tra un server e l'altro, POP,IMAP e HTTP vengono usati dall'agente utente per accedere
al servizio di posta
\subsubsection{POP3}
POP è un protocollo senza stato che gestisce le autorizzazioni e i download. Esso offre varie modalità come scarica e cancella
o scarica e mantieni per mantenere i messaggi su più client.\\La porta è la 995
\subsubsection{IMAP}
IMAP è un protocollo più complesso di POP3, con più funzioni e la possibilità di manipolare messaggi sul server.
IMAP tiene tutti i messaggi sul server, e permette all'utente di organizzarli in cartelle. IMAP inoltre mantiene 
lo stato dell'utente tra le varie sessioni.\\La porta è la 993

\subsubsection{TLS}
È un protocollo crittografico sulla comunicazione che fornisce autenticazione, integrità e confidenzialità. Il processo è 
composto da una prima negoziazione sull'algoritmo da utilizzare, poi vieno lo scambio delle chiavi e l'autenticazione. Il 
resto della comunicazione avviene con una cifratura simmetrica e autenticazione dei messaggi.

La sua evoluzione è STARTTLS che cifra la connessione sulle porte originali. Viene usata soprattutto tra Mail Transfer
Agents (MTAs) nel trasporto di una mail tra un provider e l'altro.

\subsection{DNS}
È un database distribuito che permette agli host di risolvere i nomi (o tradurre da nome a indirizzo). Questo struttura 
decentralizzata permette hal servizio di gestire un maggior volume del traffico e di essere più resistente a guasti.

La struttura gerarchica divide i server DNS authoritativi alla base per poi venire gestito dal DNS di dominio (.com,.org,...)
o server TLD (Top-Level-Domain). Infine il punto più alto viene gestito da un server root del DNS.\\
Esistono anche i DNS locali. Non fanno propriamente parte della gerarchia, ma ogni società dispone di un default name server.

Quando i server root vengono contattati dai DNS locali, possono rispondere con la mappatura richiesta, ma se non possiede
la mappatura, allora si occuperà di contattare il server autorizzato che possiede le informazioni richieste.\\ Una volta 
che un server impara una mappatura, essa viene tenuta in cache per un certo periodo di tempo.

I dati che vengono contenuti nel DNS vengono chiamati RR, o Resource Record, e contengono nome, valore, tipologia e TTL.

I messaggi DNS compongono query e risposte con lo stesso formato. L'itestazione contiene un valore d'identificazione della
query, i flag (query, aswer, richieste di ricorsione...). Nei contenuti abbiamo la domanda, l'RR di risposta, il server di 
competenza e informazioni aggiuntive.

\subsection{Condivisione P2P}
Una distribuzione P2P è molto più efficente rispetto alla gestione del singolo server. Un modello molto usato è bitTorrent.
Esso usa un server per tenere traccia dei peer che partecipano, e i torrent, o gruppi di peer che si scambiano parti di un 
file. Il file viene diviso in diversi chunk (generalmente 256kb) e distribuito a diversi peer vicini (o neighbors) durante
il download.

La parte di corrispondenza tra le informazioni e la posizione di un host è una Hash table distribuita

In un servizio completamente distribuito viene definito query flooding, dato che senza un server centrale, rischia di 
riempire la rete. Infatti la query viene inoltrata sulla rete e rediretta ai peer vicini finche non viene trovato il
destinatario

L'unione tra un indice centralizzato e query flooding è la copertura gerarchica, in questo caso ad alcuni peer viene 
assegnato il ruolo di leader di un gruppo e gestiscono le query per conto dei peer sottoposti.


\subsection{Cloud computing}
È un'archittettura che prevede diversi server reali ad alta affidabilità e fisicamente locati in un data center del
provider del servizio. In questo modo le caratteristiche fisiche sono irrilevanti per l'utente, a differenza di 
sicurezza, privacy e continuità di servizio

\subsubsection*{Content Delivery Networks}
Una CDN costruisce una rete overlay per la distribuzione di contenuti, utilizzando il concetto chiave di disponibilità
dei dati il più vicino possibile agli utenti. Questo metodo ottimizza le prestazioni di rete, riduce la latenza e 
evita i colli di bottiglia.\\Sfrutta due metodi: Enter deep, dove gli ISP installano server in tutto il mondo, e Bring 
home, con meno server, ma installati negli IXP

\subsubsection*{DASH}
Dynamic Adaptive Streaming over HTTP. È un servizio di streaming multimediale che divide i video in chunk e che 
permette al client di riceve chunk dello stesso video a server diversi, in modo da ottimizzare la visualizzazione
e ridurre i ritardi

\newpage
\section{Livello di trasporto}
I servizi e protocolli di trasporto forniscono la comunicazione tra host differenti. Dal lato invio il livello di 
trasporto scinde i messaggi in segmenti e lo passa al livello di rete,passando la comunicazione logica tra host,
mentre dal lato di ricezione riassembla i messaggi e li passa al livello applicazione, passando la comunicazione 
logica tra processi.

\subsection{Multiplexing e demultiplexing}
Il multiplexing al trasmettitore gestisce i dati da diverse socket con l'aggiunta di un header PCI, mentre il 
demultiplexing usa le PCI per consegnare i segmenti alle socket giuste

\subsection{TCP}
È un protocollo affidabile, con consegne nell'ordine originario. Implementa controllo di congestione, flusso e 
setup della connessione.

NB: controllo di flusso opera sulla ricezione dell'host, mentre il controllo di congestione opera sulla m
trasmissione in rete

\subsection{UDP}
Lo User Datagram Protocol è un protocollo best-effort, infatti i segmenti possono essere perduti o consegnati 
in ordine scorretto. UDP inoltre è un protocollo connection-less, quindi senza handshake e segmenti gestiti
indipendentemente dagli altri

\subsubsection{Checksum UDP}
Per controllare che il segmento sia giunto senza errori viene fatta la somma delle parole e calcolato il 
complemento a 1 del risultato. questo valore viene poi inserito nel campo checksum del segmento UDP. Al ricevente
basta poi rieffettuare la somma e sommare il checksum, se il risultato ha tutti i bit a 1, non è stato rilevato 
errore, se no il contrario. 

\subsection{trasferimento dati affidabile}
\subsubsection{ARQ}
L'Automatic Repeat reQuest è una classe di protocolli con lo scopo di recuperare le perdite di pacchetti.
Tra questi abbiamo:
\begin{itemize}
    \item Stop\&wait
    \item Go-back-N
    \item selective repeat
    \item TCP
    \item Protocollo MAC
\end{itemize}

\subsubsection*{Stop\&wait}
Il trasmettitore, dopo aver inviato il primo segmento, attende un ACK da parte del ricevente. Se non riceve
l'ACK entro un timeout, allora reinvia la PDU. Il ricevitore può scegliere di non inviare l'ACK in caso la PDU
risulti errata o in disordine.

\subsubsection*{Pipelining}
Questo metodo afferma che il trasmettitore consideri l'esistenza di ACK "in volo", cioé inviati ma non ancora 
ricevuti. Il selective repeat e go-back-N usano questa tecnologia. 

Alcuni termini utili sono:
\begin{itemize}
    \item finestra di trasmissione: l'insieme di PDU che vengono inviate dal trasmettitore senza aver ricevuto 
    l'ACK
    \item Finestra di ricezione: insieme di PDU che il ricevitore può accettare e immagazzinare
    \item puntatore low: puntatore al primo pacchetto della finestra di trasmissione
    \item puntatore up: puntatore all'ultimo pacchetto già trasmesso
\end{itemize}

Gli ACK utilizzati possono essere di diverso tipo: ACK individuale, ACK cumulativo (ho ricevuto fino a n), ACK
negativo (NACK) e piggybacking (ACK inseriti dentro altre PDU)

\subsubsection*{Go-back-N e selective repeat}
Il Go-back-N invia cumuli da N pacchetti, e il ricevente invia solo ACK cumulativi. Il timeout è impostato sulla
base del pacchetto più vecchio. Nel selective repeat invece il ricevente invia ACK dei singoli pacchetti. Con
questo metodo il mittente deve tenere un timer per ogni pacchetto 

\subsection{TCP}
Parliamo di un protocollo point-to-point, full-duplex, orientato alla connessione che implementa pipelining e
un flusso controllato e affidabile.

La struttura contiene campi come l'ACK, checksum, finestra di ricezione (RWND), lunghezza massima del segmento 
(MSS), retransmission timeOut (RTO) e flag di controllo della connessione.

Il setup della connessione avviene seguendo specifici passaggi:
\begin{enumerate}
    \item Host A invia un segmento con flag SYN=1, nel pacchetto è contenuto porta sorgente, destinazione e 
    numero di sequenza iniziale
    \item Host B invia un ACK con flag SYN=1 e ACK=1, nel pacchetto contiene in valori precedenti più il numero
     di ACK
    \item Host A  risponde con un segmento con flag ACK=1, il pacchetto non contiene numero di sequenza
\end{enumerate}
La chiusura della connessione invece è bidirezionale e usufruisce del flag FIN=1 con relativo ACK da entrambi gli
host. Esiste anche la chiusura tear down, più brusca, che usa il flag RST=1 per resettare la connessione

\subsubsection{Controllo di flusso}
Questo meccanismo permette al ricevitore di controllare la velocità di trasmissione del mittente.

Nel caso TCP, il ricevitore comunica le dimensioni della propria finestra di ricezione tramite il campo RWND. 
Il mittente, ricevuti i dati, si riadegua per non mandare in overflow in buffer del ricevente.

\subsection{Principi del controllo di congestione}
Con congestione intendiamo il fenomeno in cui la rete riceve più pacchetti di quelli che riesce a gestire.
Questo comporta la perdita di pacchetti e ritardi.

Un modello a code comprende un lista d'attesa per un server. Il tasso di frequenza d'arrivo è il numero medio
di pacchetti in arrivo in un lasso di tempo, mentre il tasso di frequenza di servizio è quanto velocemente 
vengono processati

\subsubsection{Cause e costi della congestione}
una congestione può rientrare in 3 categorie:
\begin{itemize}
    \item Buffer infiniti
    \subitem  nessuna perdita, ma più il tasso di arrivo si avvicina a quello di servizio più aumentano i ritardi
    \subitem costo: ritardi molto elevati
    \item Ritardi dovuti lla congestione: timeout
    \subitem costo: spreco di risorse dato da ritrasmissioni inutili
    \item pacchetti scartati a causa della congestione
    \subitem costo: ritrasmissioni, questo porterebbe a un maggior lavoro per ottenere lo stesso thorughput percepito
    a livello applicazione
\end{itemize}

\subsection{Controllo della congestione in TCP}
Esistono diversi tipi di approcci alla congestione in TCP:
\begin{itemize}
    \item controllo di congestione end-to-end
    \item controllo di congestione assistito dalla rete
\end{itemize}
Gli algoritmi utilizzati da TCP sono:
\begin{itemize}
    \item In assenza di perdite:
    \subitem Slow start
    \subitem Congestion avoidance
    \item In caso di perdite:
    \subitem Fast retransmit
    \subitem Fast recovery
\end{itemize}

\subsubsection{AIMD}
L'Additive Increase Multiplicative Decrease è un approccio in cui il mittente aumenta il tasso di trasmissione 
cercando di occupare più banda possibile, finche non si rilevano perdite. Praticamente si aumenta la finestra di 
1 MSS ogni RTT finché non ci sono perdite, e successivamente si riduce la finestra della metà. Questo metodo 
garantisce più equità fra le sessioni

\subsubsection{Slow start e Congestion avoidance}
Nello Slow start, per ogni ACK ricevuto, aumento la finestra di congestione di 1 MSS. Nel momento in cui supero 
la soglia di congestione, entro in modalità congestion avoidance. In questa modalità, per ogni RTT in cui 
ricevo tutti gli ACK attesi, aumento la finestra di congestione di 1 MSS

\subsubsection{Fast retransmit e fast recovery}
Alla ricezione del terzo ACK duplicato ritrasmetto il segmento indicato dall'ACK ed entro nella fase di fast 
recovery. Abbasso la soglia dello slow start e ricomincio a salire in maniera adittiva fino all'arrivo di un ACK
valido. A quel punto passa in congestion avoidance

NB: throughput tcp: $<\frac{MSS}{RTT}\cdot\frac{1}{\sqrt{p}}$

\subsubsection{Controllo di congestione - CUBIC}
CUBIC fa variare la lunghezza della finestra di congestione secondo una funzione cubica del tempo. Per 
compabilità con TCP, CUBIC  si comporta come TCP standard in una rete con RTT brevi 

\subsubsection{BBR}
Bottleneck Bandwidth and ROundtrip propagation time è un algoritmo che si basa sull'RTT e la banda sul 
bottleneck.\\È un protocollo progettato per rispondere a una congestione effettiva piuttosto che alla 
perdita di pacchetti, ed è implementato solo sui server (Server-side algorithm).

Oltre che ad evitare congestioni, BBR presenta anche riduzioni significative della latenza

\subsubsection{QUIC}
QUIC mira ad essere equivalente a tcp ma con una latenza inferiore. Basato su UDP con un overhead ridotto,
sfrutta l'handshake iniziale di TLS per inviare anche i dati necessari per i pacchetti futuri.

Ogni flusso è controllato separatamente, in maniera che lo stack di protocollo non è fermato da un singolo 
flusso.\\Inoltre, QUIC usa degli identificatori di connessione, che risultano indipendenti al cambio di rete,
al contrario di TCP che si rallenta per ripristinare le connessioni

\newpage
\section{Livello di rete}
\subsection{Visione d'insieme}
Le due operazioni principali a livello di rete sono il forwarding e il routing. La prima è un'operazione con scala
locale che sposta un pacchetto dall'entrata all'uscita di un router, mentre la seconda è a scala globale e
determina il percorso che il pacchetto deve seguire. Le due parti si suddividono nel data plane e control plane,
le logiche locali e globali del router

\subsection{Il router}
possiamo dividere il router in processore (software, control plane) e porte d'ingresso, uscita e sistema di
commutazione ad alta velocità (hardware, data plane)

\subsubsection{Porte d'ingresso}
Composte da terminazione di linea, protocollo di ricezione e buffer, utilizzano gli header per indirizzare
i pacchetti alla porta d'uscita corretta tramite le tabelle di inoltro, cercando di non introdurre ritardi 
ulteriori

\subsubsection{Sistemi di commutazione}
Usano tre strutture: a memoria, a bus e a matrice. La commutazione a memoria è la più vecchia e utilizzava la 
CPU per l'indirizzamento. La commutazione a bus usa un bus dati condiviso per trasmettere il datagrammi alle 
uscite. Infine la commutazione a matrice usufruisce di punti di intercocnnessione tra line d'ingresso ed uscita

\subsubsection{Porte d'ingresso ed uscita}
un commutatore più lento delle porte causa accodamenti agli ingressi. Quando un datagramma al primo posto 
della coda blocca quelli successivi è chiamato Head of line (HOL). Alle porte d'uscità invece vengono
applicate delle politiche di scheduling. La dimensione dei buffer è definita nella RFC 3439, ossia un RTT
generico moltiplicato per la velocità del link, il tutto diviso dalla radice del numero di flussi disponibili

\subsubsection{meccanismi di scheduling}
Lo scheduling avviene per meccanismo FIFO, ma nel momento in cui la coda si riempie, vengono usati 3 metodi per
lo scarto dei pacchetti: tail drop (scarto pacchetti in arrivo), priority drop e random drop

\subsection{Protocollo IP}
\subsubsection{Datagramma}
I campi del pacchetto ip sono: VER (versione), lunghezza header, tipo di servizio, lunghezza totale, id, flag,
offset, TTL, protocollo superiore, checksum, ip sorgente, ip destinazione, opzioni ip, padding

\subsubsection{frammentazione}
Ciascuna rete diversa può richiedere una MTU, o limite dati massimo di trasmissione, specifica, perciò il router
frammenta i datagrammi e li invia impostando il flag che indica la frammentazione e il campo offset specificando
come concaternare i frammenti. Inoltre copia i campi necessari dall'header originale.\\I flag che vengono usati 
sono D (do not fragment) e M (more fragments comming)

La frammentazione a livello IP è disabilitata su internet per mitigare gli attacchi di overlapping fragments, 
DDos di riempimento di memoria e errori di assemblaggio dei frammenti

\subsubsection{indirizzi IP}
gli host e router devono usare le stesse convenzioni, l'indirizzo IP pubblico deve essere unico, ogni
interfaccia ha un indirizzo IP

Gli indirizzi IP sono generalmente divisi in due parti: 
\begin{itemize}
    \item Prefisso: l'identificatore della rete (NetID)
    \item suffisso: identifica l'interfaccia di rete (HostID)
\end{itemize}
in passato venivano usate diverse classi di indirizzi, con diverse lunghezze dei prefissi

Le autorità per l'assegnazione degli indirizzi sono l'ICANN (Internet Corporation for Assigned Names and Numbers)
che usano i registrar per consentire agli ISP di gestire blocchi di indirizzi

\subsubsection{Indirizzamento classless}
Il metodo classless permette agli ISP di assegnare prefissi di rete che permettono di gestire numeri specifici 
di host. Quindi per determinare la dimensione del prefisso si utilizzano le maschere di rete, ossia 32 bit 
impostati a 1 fino al prefisso. Questo metodo permette un uso efficente dell'AND logico per determinare il NetID.
\\La notazione /x è chiamata notazione CIDR

L'inoltro con CIDR usufruisce della subnet per determinare la rete e l'interfaccia ad essa collegata. In caso 
di multiple corrispondenze si usufruisce della regola del longest prefix matching

I router usufruiscono di una tabella di routing per definire ad ogni interfaccia quali reti sono collegate

\subsubsection{Indirizzi pubblici e privati}
La maggioranza di indirizzi IP è pubblica e vengono gestiti dagli ISP, mentre invece per le reti a gestione 
privata vengono riservati 3 intervalli di indirizzi:
\begin{itemize}
    \item 10.0.0.0/8 (fino a 10.255.255.255)
    \item 172.16.0.0/12 (fino a 172.31.255.255)
    \item 192.168.0.0/16 (fino a 192.168.255.255)
\end{itemize}

\subsubsection{Indirizzi speciali}
Ecco un elenco di indirizzi speciali in IPv4:
\begin{itemize}
    \item Indirizzi di rete
    \subitem Usati come riferimento ad una rete, impostano tutti i bit HostID a 0
    \item Indirizzi broadcast di una rete
    \subitem Sono indirizzi broadcast che possono essere inoltrati da un router a una determinata rete. Si 
    ottengono settando tutti i bit HostID a 1
    \item Indirizzo broadcast di una rete locale
    \subitem 255.255.255.255: Usato per la comunicazione broadcast locale, non viene inoltrato dai router  
    \item Indirizzo sconosciuto
    \subitem 0.0.0.0: Usato per determinare indirizzi non validi o non ancora assegnati, come all'inizio 
    di un discovery DHCP 
    \item Indirizzo di loopback
    \subitem 127.0.0.1: Usato da un host per comunicare con se stesso. Per esempio viene usato per testare le 
    app di rete 
    \item Indirizzi multicast
    \subitem Usati per inviare pacchetti a un gruppo di host, iniziano tutti con 1110 (224.0.0.0$\to$
    239.255.255.255). Il traffico multicast è minimo, molto spesso bloccato su internet
    \item Indirizzi link-local
    \subitem 169.254.0.0/16: una sottorete usata per le comunicazioni quando un host non riesce a trovare 
    un indirizzo IP
    \item Indirizzi per router
\end{itemize}


\subsubsection{Network Address Translation}
Per connettere reti con indirizzo privato a internet, vengono usate due tecnologie: un proxy (dispositivo con un 
indirizzo pubblico e uno privatio che fa da middleman) e il NAT, ossia un apparato che si interfaccia a internet 
e effettua una mappatura degli indirizzi privati convertiti in porte dell'indirizzo pubblico.\\
NAT offre 60 mila connessioni simultanee grazie alle porte a 16 bit.

\subsubsection{ARP}
L'Address Resolution Protocol viene utilizzato per trovare l'indirizzo MAC asseggnato ad un determinato indirizzo
IP. Il funzionamento si basa su una richiesta in broadcast fatta dal mittente alla ricerca di un destinatario 
specifico. Se un host corrisponde a quel destinatario risponde con il suo indirizzo MAC, se no scarta il messaggio.

Per evitare di floodare la rete con richieste ARP, le risposte vengono salvate in memoria, e in caso di nuove 
corrispondenze, le vecchie risposte vengono sovrascritte o scartate dopo 30 secondi

Una macchina può anche essere configurata come ProxyARP, ossia una macchina che inoltra i messaggi ARP 
su un'altra rete spacciandosi come host mittente. Questo sistema permette di gestire sottoreti come una rete 
unica

\subsubsection{ICMP}
Questo è un protocollo usato per la gestione e manutenzione delle reti. Funziona in simbiosi con IP dato che 
IP usa ICMP per segnalare gli errori, e ICMP usa IP per trasportare i messaggi.
Questi messaggi sono molteplici, ognuno con il proprio ruolo, ma si dividono in due classi principali: quelli
usati per recuperare informazioni sullo status della rete e quelli per segnalare errori. Alcuni esempi sono
destination unreachable, time exceeded, redirect...
Particolarità dei messaggi ICMP è che nel generarsi di un errore, nessun messaggio viene inviato, in modo da evitare
la congestione della rete

\subsubsection{DHCP}
È un protocollo basato su UDP per l'assegnazione automatica dell'indirizzo IP a un host sprovvisto, e di riabilitare
indirizzi non utilizzati da un certo periodo di tempo. La procedura è come segue:
\begin{enumerate}
    \item L'host invia un messaggio DHCP discover per identificare i server DHCP nella rete
    \item Il server DHCP risponde con un DHCP offer
    \item L'host richiede un indirizzo con un DHCP request al server selezionato
    \item Il server invia un DHCP ack
\end{enumerate}
Nel caso il client non trovi alcun server DHCP, allora può scegliere casualmente un indirizzo tra 169.254.0.1 e
169.254.255.254, controllare se è occupato e in caso contrario, impostarlo come indirizzo di rete locale

L'assegnazione di un indirizzo con DHCP vale solo per un periodo limitato. Questo prestito viene definito come lease,
e, al suo termine, permette di spostare gli indirizzi IP prestati tra quelli utilizzabili. Generalmente un client
può chiedere l'aggiornamento dell'indirizzo IP o l'estensione del lease.\\Il DHCP è in grado di restituire anche 
nome e IP di un server DNS

Il formato del messaggio DHCP contiene i campi:
\begin{itemize}
   \item YOUR IP ADDRESS: contiene l'IP offerto al client
   \item SERVER IP ADDRESS, SERVER HOST NAME
   \item ROUTER IP ADDRESS: contiene l'indirizzo del default gateway
   \item altri campi come: OP, HTYPE, HLEN, FLAGS, HOPS, TRANSACTION IDENTIFIER, SECOND ELAPSED
\end{itemize}

\subsubsection{IPv6}
La funzione di IPv6 usa un header fisso a 40 byte e proibisce la frammentazione. La sua funzione è quella di estendere
la quantità di indirizzi, velocizzare l'elaborazione dei datagrammi e facilitare la gestione del servizio.\\Altre 
modifiche rispetto a IPv4 è la rimozione del checksum, la rimozione delle option nell'header e spostate nel campo
"NEXT HEADER" e implementazione di ICMPv6.

L'indirizzo IPv6 è formato da 128 bit con notazione esadecimale, utilizza i due punti per separare gli otteti e 
permette di riassumere gli indirizzi con due regole:
\begin{itemize}
    \item dove presenti multipli zeri consecutivi, possono essere accorciati con un singolo 0
    \subitem f108:0083:b00c $\Rightarrow$ f108:83:b00c 
    \item i gruppi consecutivi di zeri si riassumono con due due punti di fila, ma una volta sola
    \subitem  f108:0000:0000:b00c $\Rightarrow$ f108::b00c
\end{itemize}

Per permettere una transizione graduale da IPv4 a IPv6, è stato implementato il tunneling, ossia la possibilità di
incapsulare dei datagrammi IPv6 in datagrammi IPv4

Il pacchetto contiene i campi:
\begin{itemize}
    \item FLOW LABEL
    \item PRIORITY 
    \item NEXT HEADER
\end{itemize}

gli indirizzi speciali sono: 
\begin{itemize}
    \item ::/128: non specificato, o "questo computer"
    \item ::1/128: indirizzo di loopback
    \item ::ffff:0:0/96: indirizzo IPv4 mappato su IPv6
    \item ff00::/8: multicast
    \item fe80:::/10: linklocal unicast
\end{itemize}

\subsection{Protocolli di instradamento}
Un percorso di routing viene definito come efficente in base a diverse metriche come il percorso a costo più basso, 
più veloce o meno congestionato.

Una rete può essere espressa come un grafo dove i nodi sono i router e gli archi i link. Ad ogni arco viene assegnato 
un costo (congestio, numero di salti,...) e il costo di percorso corrisponde alla somma di tutti gli archi necessari 
per collegare il nodo A al nodo B. Per determinare qual'è il percorso migliore vengono usati gli algoritmi di routing.\\
Gli algoritmi possono essere divisi in vari tipi in base se le informazioni sugli altri router sono globali o
distribuite e se i percorsi sono statici o dinamici (cambiano raramente o spesso):
\begin{itemize}
    \item informazioni globali: tutti i router conoscono la topologia e costi della rete. Implica algoritmi a 
    "link state"
    \item informazioni distribuite: i router conoscono le informazioni dei router collegati a loro e il calcolo del
    percorso è iterativo. Implica algoritmi a "distance vector"
\end{itemize}

\subsubsection{Algoritmo di Dijkstra}
è un algoritmo link state che presuppone che tutti i nodi conoscano la topologia e i costi della rete.

NB: qualche notazione:
\begin{itemize}
    \item $c(x,y)$: costo del link tra $x$ e $y$
    \item $D(v)$ costo del percorso verso $v$
    \item $p(v)$: predecessore di $v$ 
    \item $N'$ insieme di nodi con cammino a costo minimo già determinato
\end{itemize}

Il funzionamento dell'algoritmo è come consegue:
\begin{center}
    
\begin{tabular}{l}
    \texttt{INIZIALIZZAZIONE}\\
    \texttt{N'=\{u\}}\\
    \texttt{for all nodes v}\\
    \texttt{ if(v è  adiacente a u)}\\
    \texttt{ \ then D(v)=c(u,v)}\\
    \texttt{ else D(v)=$\infty$   }\\\\
    \texttt{LOOP}\\
    \texttt{ Trova w non contenuto in N' tale che D(w) è  minimo}\\
    \texttt{ Aggiungi w a N'}\\
    \texttt{ Aggiorna D(v) per tutti i nodi v adiacenti a w e non contenuti in N'}\\
    \texttt{ if(D(w)+c(w,v)<D(v) then)}\\
    \texttt{ \ D(v)=D(w)+c(w,v)}\\
    \texttt{ \ p(v)=w}\\
    \texttt{ end if}\\
    \texttt{UNTIL(tutti i nodi sono contenuti in N')}\\
    \end{tabular}
\end{center}

Questo algoritmo possiede una complessità di O($n^{2}$) con implementazioni più efficenti che posso scendere fino
a O($n*log(n)$)

\subsubsection*{Internet e gli AS}
Internet è formata da sottoreti con diversi propritari. Queste reti dovrebbero essere amministrativamente autonome
e capace di collegarsi a tutte le altre reti. Per questo i router sono organizzati in autonomous systems

\subsubsection{OSPF}
Open Shortest Path First è un protocollo link state che calcola i percorsi usando l'algoritmo di Dijkstra.
I suoi pacchetti aggiornano gli altri router usando indirizzi multicast.

Procedure:
\begin{itemize}
    \item protocollo di "Hello": messaggi di mantenimento e controllo deil'up-state dei link
    \item protocollo di "Exchange": usato per informare nuovi router della topologia della rete
    \item protocollo di "Flooding": informa tutti i router di un cambio di link nella rete
\end{itemize}

OSPF implementa anche una versione gerarchica usata nelle reti con molti router. Questa versione presenta due livelli:
le backbone e le reti di area. In questo modo i router conoscono solo la topologia della propria area e uno 
shortest path verso le altre reti. I router che interfacciano un area con la backbone vengono chiamati router di 
bordo, e applicano OSPF solo per i router all'interno dell'area di backbone

\subsubsection{Distance Vector Routing}
È un algoritmo distribuito che non richiede la conoscenza della topologia della rete, ma solo i router confinanti.
Il modello usato è quello di Bellman-Ford 

NB: Notazione:
\begin{itemize}
    \item $N$: insieme dei vicini
    \item $R$: tabella di inoltro
    \item $D$: vettore con tutte le distanze
\end{itemize}

Algoritmo per il nodo $x$:
\begin{center}
    \begin{tabular}{l}
        \texttt{INIZIALIZZAZIONE}\\
        \texttt{Per tutti i vicini n$\in N_{x}$:}\\
        \texttt{ $R_{x}$[n].cost=c(x,n),$R_{x}$[n].nexthop=n, $R_{x}$.time=adesso}\\
        \texttt{Ogni T secondi:}\\
        \texttt{ invia $D_{x}$=[(d, $R_{x}$[d].cost) tale che d $\in R_{x}$] a tutti i vicini in $N_{x}$}\\
        \texttt{Quando si riceve un vettore $D_{y}$ dal vicino y:}\\
        \texttt{ Per ogni (d,c)$\in D_{x}$:}\\
        \texttt{ \ if d$\notin$ R or c + c(x,y)<R[d].cost or y=R[d].nexthop}\\
        \texttt{ \ \ R[d].cost = c + c(x,y)}\\
        \texttt{ \ \ R[d].nexthop = y}\\
        \texttt{ \ \ R[d].time = adesso }\\
    \end{tabular}
\end{center}

Distance vector nel libro:
\begin{center}
    \begin{tabular}{l}
        \texttt{INIZIALIZZAZIONE}\\
        \texttt{Per tutte le destinazioni y $\to$ $D_{x}$(y)=c(x,y)}\\
        \texttt{Per tutti i vicini w, e tutte le destinazioni y $\to D_{w}$(y)=?}\\
        \texttt{Per ogni vicino w $\to$ invia $D_{x}=[D_{x}$(y):y in $N_{x}$] a w}\\
        \texttt{LOOP}\\
        \texttt{Aspetto finche il costo verso un vicino non cambia o non ricevo $D_{w}$ da w}\\
        \texttt{Per ogni destinazione y:}\\
        \texttt{ $D_{x}$(y)=min$_{v}$\{c(x,v)+D$_{v}$(y)\}}\\
        \texttt{ next-hop$_{x}$=argmin$_{v}$\{c(x,v) + D$_{v}$(y)\}}\\
        \texttt{if D$_{x}$(y) è cambiato per una qualsiasi destinazione y:}\\
        \texttt{ invia D$_{x}$=[D$_{x}$(y):y in N$_{x}$] a tutti i vicini}\\
        \texttt{forever}\\
    \end{tabular}
\end{center}

L'algoritmo permette di attuare cambiamenti positivi alla rete in fretta, ma quelli negativi lentamente

Può succedere con questo metodo che si generi un count to infinity: Se un router A raggiunge un router 
C tramite il router B, e il collegamento BC cade, B chiederà ad A una nuova route verso C, che A 
conosce attraverso B con un costo x. Allora B aggiorna la sua routing table per costare 2x, e 
aggiornando A farà aumentare il suo costo di 2x, portandolo a 3x, e così via all'infinito.\\
Per risolvere questo problema si possono usare diverse tecniche:
\begin{itemize}
    \item Impostare un massimo numero di hop
    \item Split Horizon: quando un nodo manda gli aggiornameti a un nodo ignora quelli ricevuti da esso
    \item Poisoned reverse: il nodo A dice a B che la distanza da Z è infinita
\end{itemize}

Attenzione che in base alla topologia e ordine dei messaggi, lo split horizon e poisoned reverse non sono 
sempre ottimali

\subsection{RIP}
Il Routing Information Protocol è un protocollo intra-AS a livello applicazione che implementa il distance
vector. Risulta così facile da implementare e gestire ma vale solo su reti di dimensioni limitate e può
risultare lento in convergenza.\\Il costo viene definito dal numero di hop, al massimo 15. Ogni 30 secondi
e al variare delle tabelle di routing, viene inviato un RIP advertisement contenente fino a 25 sottoreti
e la distanza rispetto a Ciascuna sottorete

NB: usa UDP, porta 520, multicast 224.0.0.9

Nel momento in cui un router va offline per oltre 180 secondo viene considerato guasto dai nodi vicini.
Le tabelle vengono quindi modificate e inoltrate ai router vicini. Infine viene applicato i poisoned 
reverse

\subsubsection*{Confronto link state e distance vector}
In complessita dello scambio di messaggi DV semplifica il processo, ma estende il tempo di convergenza
rispetto a LS, e si potrebberò generare cicli. Inoltre in caso di "rottura" del router, DV potrebbe 
propagare gli errori attraverso la rete.\\Concludendo LS risulta più robusto rispetto a DV, anche se 
computazionalmente più pesante


\newpage
\section{Data link}
Gli host e i router si comportano come nodi di una rete, mentre gli archi sono i vari link, che possono 
essere sia cablati che wireless. \\I pacchetti di livello data link sono chiamati frame. 

Il compito di questo livello è il trasporto da un nodo all'altro, nonostante i link possono essere di 
vari tipi e con protocolli (con i relativi servizi) diversi. \\Nello specifico, la creazione di un 
frame avviene tramite:
\begin{itemize}
    \item Incapsulamento di un datagramma in frame, con relativi header e trailer
    \item Fornitura di un meccanismo d'accesso al canale di comunicazione
    \item Identificazione di mittente e destinatario tramire indirizzo MAC 
\end{itemize}
Viene anche implementato un controllo di errore per le connessioni con alti tassi d'errore.\\ Altri
servizi offerti dal livello datalink sono il controllo di flusso, correzzione d'errore e comunicazione
half/full-duplex

Il livello datalink viene implementato dall'adattatore di rete all'interno di un host

\subsection{Rilevamento di errori}
Nel datagramma, oltre che il controllo di parità, esiste il campo EDC (Error Detection and Correction) 
che contiene il numero di bit ridondanti inseriti. 

Viene usato CRC (Cyclic Redundancy Check), ossia l'algoritmo più efficente per il rilevamento di errore


%%%%%%%%% ANALISI CRC %%%%%%%%%

\subsection{Tipi di collegamento}
Nel momento in cui due o più trasmissioni partono simultaneamente da nodi diversi si può generare un'interferenza.
Per questa ragione è necessario un protocollo di accesso multiplo ad un mezzo. Questi protocolli si chiamano MAC
(Multiple Access Control) e rientrano in tre tipi di classi:
\begin{itemize}
    \item Ripartizione delle risorse del canale (cioé creando sotto canali)
    \item ad accesso casuale
    \item A turni intelligenti
\end{itemize}

\subsubsection{TDMA}
Time Division Multiple Access permette di accedere a un canale fisico a turni. Ogni nodo ottiene un intervallo
(o frame) definito per comuncare, al di fuori non è permesso, anche se non c'è alcuna comunicazione

\subsubsection{FDMA}
Frequency Division Multiple Access separa lo spettro del canale in sotto bande. Lo spartizionamento è simile a
TDMA

\subsubsection{CDMA}
Code Division Multiple Access separa le risorse assegnando un codice a ogni nodo. Questo codice è definito da
bit con durata minore rispetto a quelli dei dati

\subsection{Protocolli ad accesso casuale}
Si occupano di definire come rilevare e recuperare da uno stato di collisione

\subsubsection{Slotted ALOHA}
I nodi possono comunicare a intervalli ben precisi, nel momento in cui viene registrata una collisione, viene 
definito da ogni nodo un tempo di attesa casuale prima di riprovare la trasmissione. \\
Questo metodo decentralizzato è molto elementare, ma allo stesso tempo molto inefficente, molte occasioni 
di comunicazione vengono bruciate. L'efficenza si aggira intorno allo 0.368

\subsubsection{ALOHA puro}
Non implementando la sincronizzazione, risulta ancora più semplice e incline alle collisioni e sprechi.
L'efficenza scende a 0.184

\subsection{CSMA}
Il Carrier Sense Multiple Access si occupa di comunicare solo nel momento in cui il canale risulta libero.
Può avere diversi livelli di persistenza:
\begin{itemize}
    \item 0-persisente (o non persistente): se trova il canale occupato attende un tempo casuale prima di
    ritentare la connessione
    \item 1-persistente: attende finché non si libera il canale, se si verifica una collisione attende un 
    tempo casuale prima di riaplicare la procedura
    \item p-persistente: attende il canale libero, e con una probabilità p trasmette, se no attende un
    tempo casuale prima di riaplicare la procedura
\end{itemize}

CSMA definisce un "periodo di vulnerabilità", ossia la somma del tempo di propagazione e rilevazione 
dell'occupazione del canale che compone un intervallo di tempo dove un nodo potrebbe comunicare 
non avendo ancora rilevato che il canale è occupato provocando una collisione.\\
Insomma, CSMA si usa quando il tempo di propagazione è minore rispetto a quello di trasmissione

\subsubsection{CSMA/CD e CSMA/CA}
La Collision Detection di CSMA permette di rilevare rapidamente le collisioni e interrompere la trasmissione.
Questo risulta più arduo nelle connessioni wireless piuttosto che cablate. Di conseguenza si implementa il 
Collision Avoidance

\subsubsection{Protocolli MAC "a turni"}
\subsubsection*{Polling}
Un nodo "master" da il permesso ai nodi "slave" per comunicare. Comporta alta latenza, occupazione del canale
e single point of failure nel master
\subsubsection*{Token passing}
sfrutta il passaggio sequenziale di un token per permettere la comunicazione. Possiede problemi di latenza e 
single point of failure nel token

\subsection{IEEE 802 e ethernet}
Il gruppo IEEE 802 ha sviluppato alcuni degli standard più importanti nel campo delle reti: 802.1 LAN, 802.3
Ethernet, 802.8 fibre ottiche, 802.11 WLAN, 802.15 PAN...

La struttura del frame ethernet avvolge il pacchetto di livello superiore con 7 byte usati per la 
sincronizzazione del clock tra ricevitore e trasmettitore. Dopo di che contiene indirizzo MAC del destinatario
e del mittente (in questo ordine) e in fondo il CRC

Ethernet non implementa ne controllo di connessione ne ACK per il recupero di frame persi, è compito dei 
protocolli di livello superiore di controllare. Per il controllo delle collisioni, è implementato un 
CSMA/CD p-persistente.

Gli standard di internet variano in base ai mezzi fisici e velocità di trasmissione, ma protocollo MAC e 
formato sono costanti

\subsection{Switch Ethernet}
Questi dispositivi di livello 2 usano il MAC per memorizzare e inoltrare frame Ethernet. Sono anche 
dispositivi ad autoapprendimento (plug and play) e trasparenti, ossia gli host non sanno della loro presenza.\\
Gli switch sono anche in grado di separare i domini di collisione dato che ogni host può essere direttamente
collegate allo switch

Gli switch implementano tabelle di inoltro che contengono indirizzo MAC e relativa interfaccia dello switch.
Queste tabelle autoapprendono ogni volta che ricevono un pacchetto ethernet da un nuovo mittente su un'interfaccia
Nel caso il destinatario non sia conosciuto, allora flodda tutte le interfaccie tranne quella mittente

\subsubsection{Spanning Tree Protocol}
Anche gli switch sono vulnerabili ai loop, per questo è stato creato un protocollo che partendo dal grafo della 
rete ne restituisce un albero. Per raggiungere questo obbiettivo ogni switch è identificato con un ID 
formato da bit impostati dall'amministratore seguiti dal MAC address. Il protocollo imposta come radice il 
dispositivo con l'ID più basso

Gli switch si passano Bridge Protocol Data Unit contenenti ID e costo del link. In base a questi valori lo 
switch decide la sua radice. Infine le BPDU vengono inviate con "l'invecchiamento" dell'ultima BPDU arriavata
per aggiornare lo stato della rete.\\ Le porte dello switch con STP possono prendere 3 stati: Root, Blocked
e Designated

\subsubsection{VLAN}
Gli host possono essere suddivisi in LAN diverse per vari motivi, come spartizione del carico e separazione dei
domini di broadcast e intenti. Questa suddivisione può essere gestita tramite software con le VLAN.\\
Le VLAN fondamentalmente raggruppano vari porte in una singola rete. Questa tecnologia ha portato alla 
stesura di un nuovo standard Ethernet, l'802.1Q. Questo standard aggiunge alcuni campi tra cui VLAN ID

\subsection{IEEE 802.11 - WiFi}
\subsubsection{Elementi e terminologie}
\begin{itemize}
    \item Host wireless
    \item stazione base: ponte tra etere e rete cablata
    \item collegamento wireless: gestito dai vari protocolli
    \item modalità infrastrutturata: permette il passaggio di un host da una stazione base all'altra
    \item modalità ad hoc: non ci sono stazioni base e gli host comunicano solo nel loro raggio di copertura
\end{itemize}

\subsubsection{Archittettura di riferimento}
\begin{itemize}
    \item Stazione wireless (STA): host
    \item Basic Service Set (BSS): gruppo di STA connessi allo stesso canale radio
    \item Access Point (AP): Stazione base
    \item Sistema di distribuzione
    \item Extended Service Set (ESS): unisce più BSS in un unica rete logica
    \item Portale: verso altre reti
\end{itemize}

\subsubsection{Scansione passiva e attiva}
Un host per connettersi a un AP deve esaminare tutti i canali disponibili e communicare con frame speciali chiamati
beacons. Questo meccanismo può essere diviso in due tipologie: quella passiva, dove è l'AP a inviare i beacon e 
l'host richiede all'AP se può connettersi. In quella attiva invece, è l'host a inviare "probe request" ed è poi 
l'AP ad offrire la connesione.

\subsubsection{Trasmissione e collision detection}
I segnali wireless sono meno potenti e subiscono molte più interferenze, anche dallo stesso segnale, per via 
delle proprietà fisiche della trasmissione radio. Un'antenna non può neanche trasmettere e ricevere 
contemporaneamente. 

Per ovviare questi problemi, le STA si contendono il canale d'accesso ogni volta che devono trasmettere. Possono 
comunicare solo se il canale rimane libero per un tempo definito Distributed Inter-Frame Space (DIFS) e attende
un tempo casuale in caso di canale occupato. Gli ACK vengono inviati in un atro intervallo di tempo minore, il
Short Inter-Frame Space (SIFS). Gli ACK vengono usati anche per determinare le collisioni

Può succedere però che un host sia in grado di comunicare con l'AP, ma non con un altro host per via di un
ostacolo tra i due. Per questo viene usato un handshake specifico con RTS (Request To Send) e CTS (Clear To 
Send). Al seguito di un CTS, viene notificato agli altri STA della trasmissione imminente, rimuovendo il 
problema del terminale nascosto

\subsubsection{Frame 802.11}
Il frame contiene 4 campi per gli indirizzi, che possono contenere:
\begin{enumerate}
    \item MAC del ricevitore
    \item MAC del trasmettitore
    \item MAC del router al quale l'AP è collegato
    \item usato solo nelle reti ad hoc
\end{enumerate}
\end{document}